# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

binFit64ToDepth <- function(dmat, bitdepth) {
    .Call('feature2_binFit64ToDepth', PACKAGE = 'feature2', dmat, bitdepth)
}

Blur2D <- function(dmat, bitdepth, num_rows_kernel, num_cols_kernel, center_row = -1L, center_col = -1L, borderType = "default") {
    .Call('feature2_Blur2D', PACKAGE = 'feature2', dmat, bitdepth, num_rows_kernel, num_cols_kernel, center_row, center_col, borderType)
}

borderTypeCode <- function(borderType) {
    .Call('feature2_borderTypeCode', PACKAGE = 'feature2', borderType)
}

#' @name CCF_2D
#' @title CCF_2D
#' @description 2D Cross-correlation function.
#' 
#' @details Sets up and calls openCV's \code{matchTemplate} with method=CV_TM_CCOEFF_NORMED (i.e. compute the 
#' nomalized correlation coefficients). NOTE: The surface must be converted to 8- or 32-bit floating point 
#' (bitdepth option = "8bit" or "32bitfloat") for use with \code{matchTemplate}. If the surface/image is
#' not converted, \code{matchTemplate} will throw an error.
#' 
#' The \code{matchTemplate} uses the FFT trick for speed and as such computed the CCF over all possible forward 
#' (right) lags of the template surface/image over the M by N reference (query) surface/image. \code{matchTemplate} assumes
#' the P by Q template fits inside the querry. If it does not, \code{CCF_2D} pads the query with zeros (M<P or N<Q) or switches who
#' is considered the "template" and who is considered the "query" (M<P and N<Q).
#' 
#' In order to implement correlation over shifts of the template that go over the edges of the query, the query is
#' padded with zeros by amounts to accomidate the template overhang for these shifts.
#' 
#' @usage NumericMatrix CCF_2D(NumericMatrix dmat, NumericMatrix tmplte, int x_maxlag, int y_maxlag, std::string bitdepth)
#' 
#' @param dmat     \code{NumericMatrix}. The reference (query) surface/image. See Details section.
#' @param tmplte  \code{NumericMatrix}. The template surface/image. See Details section.
#' @param x_maxlag \code{int}. Minimum max-lag in the x-direction (column shift) required. If it is less than the 
#'                 number of columns of the query, it's ignored.
#' @param y_maxlag \code{int} Minimum max-lag in the y-direction (row shift) required. If it is less than the 
#'                 number of rows of the query, it's ignored.
#' @param bitdepth \code{std::string}. "8bit" or "32bitfloat". Bit-depth to scale surface/image down to. See
#'                 Details section. 
#' 
#' @return A \code{NumericMatrix} of correlation values over shifts of the template with respect to the query. 
#' NOTE: the correlation values are tabulated by openCV in single percision (32-bit floats), and then converted to double percision
#' when they are returned to the R-side.
#' 
#' @references J.P. Lewis, Fast Template Matching, Vision Interface 95, Canadian Image Processing 
#' and Pattern Recognition Society, Quebec City, Canada, May 15-19, 1995, p.  120-123.
#'
#' @examples XXXX
NULL

CCF_2D <- function(dmat, tmplte, x_maxlag, y_maxlag, bitdepth) {
    .Call('feature2_CCF_2D', PACKAGE = 'feature2', dmat, tmplte, x_maxlag, y_maxlag, bitdepth)
}

testscale <- function(dmat, bitdepth, printQ = FALSE) {
    invisible(.Call('feature2_testscale', PACKAGE = 'feature2', dmat, bitdepth, printQ))
}

testConvert <- function(dmat, printQ = FALSE) {
    .Call('feature2_testConvert', PACKAGE = 'feature2', dmat, printQ)
}

Circular_Mask_ROI <- function(dmat, xc_idx, yc_idx, pix_radius) {
    .Call('feature2_Circular_Mask_ROI', PACKAGE = 'feature2', dmat, xc_idx, yc_idx, pix_radius)
}

Crop_Retangular_ROI <- function(dmat, Xstart_index, Ystart_index, Width, Height) {
    .Call('feature2_Crop_Retangular_ROI', PACKAGE = 'feature2', dmat, Xstart_index, Ystart_index, Width, Height)
}

DFTMag2D <- function(dmat, bitdepth) {
    .Call('feature2_DFTMag2D', PACKAGE = 'feature2', dmat, bitdepth)
}

Display2D_openCV <- function(dmat, rowWidth, colWidth, bitdepth, file_ext, printQ, exe_path) {
    invisible(.Call('feature2_Display2D_openCV', PACKAGE = 'feature2', dmat, rowWidth, colWidth, bitdepth, file_ext, printQ, exe_path))
}

Fill_Holes <- function(dmat, mask) {
    .Call('feature2_Fill_Holes', PACKAGE = 'feature2', dmat, mask)
}

Filter2D <- function(dmat, kernel, bitdepth) {
    .Call('feature2_Filter2D', PACKAGE = 'feature2', dmat, kernel, bitdepth)
}

FindHoles <- function(dmat_mask, mode, approx_method, big_hole_tol) {
    .Call('feature2_FindHoles', PACKAGE = 'feature2', dmat_mask, mode, approx_method, big_hole_tol)
}

GaussianBlur2D <- function(dmat, bitdepth, num_rows_kernel, num_cols_kernel, sigmaX = 0.0, sigmaY = 0.0, borderType = "default") {
    .Call('feature2_GaussianBlur2D', PACKAGE = 'feature2', dmat, bitdepth, num_rows_kernel, num_cols_kernel, sigmaX, sigmaY, borderType)
}

lewis3 <- function(u_idxs, v_idxs, nz_idxs, ff, offset1, offset2, offset3) {
    .Call('feature2_lewis3', PACKAGE = 'feature2', u_idxs, v_idxs, nz_idxs, ff, offset1, offset2, offset3)
}

Pad_NumericMatrix <- function(dmat, top, bottom, left, right, border_type, value) {
    .Call('feature2_Pad_NumericMatrix', PACKAGE = 'feature2', dmat, top, bottom, left, right, border_type, value)
}

numvec_to_python <- function(name, x) {
    invisible(.Call('feature2_numvec_to_python', PACKAGE = 'feature2', name, x))
}

pyrun <- function(command) {
    invisible(.Call('feature2_pyrun', PACKAGE = 'feature2', command))
}

initialize_python <- function() {
    invisible(.Call('feature2_initialize_python', PACKAGE = 'feature2'))
}

finalize_python <- function() {
    invisible(.Call('feature2_finalize_python', PACKAGE = 'feature2'))
}

Resize <- function(dmat, num_rows, num_cols) {
    .Call('feature2_Resize', PACKAGE = 'feature2', dmat, num_rows, num_cols)
}

RollColumns <- function(dmat, direction, n) {
    .Call('feature2_RollColumns', PACKAGE = 'feature2', dmat, direction, n)
}

RollRows <- function(dmat, direction, n) {
    .Call('feature2_RollRows', PACKAGE = 'feature2', dmat, direction, n)
}

Sobel <- function(dmat, bitdepth, ddepth, dx, dy, ksize = 3L, scale = 1.0, delta = 0.0, borderType = 4L) {
    .Call('feature2_Sobel', PACKAGE = 'feature2', dmat, bitdepth, ddepth, dx, dy, ksize, scale, delta, borderType)
}

vec2mat <- function(row_idxs, col_idxs, mat_elems, num_rows, num_cols) {
    .Call('feature2_vec2mat', PACKAGE = 'feature2', row_idxs, col_idxs, mat_elems, num_rows, num_cols)
}

vltest <- function() {
    invisible(.Call('feature2_vltest', PACKAGE = 'feature2'))
}

WriteMat <- function(dmat, bitdepth, fpath) {
    invisible(.Call('feature2_WriteMat', PACKAGE = 'feature2', dmat, bitdepth, fpath))
}

